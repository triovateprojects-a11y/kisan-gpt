<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Krishi Mitra</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://generativelanguage.googleapis.com/v1beta/models"></script>
  <link rel="stylesheet" href="style.css">
  <style>
    /* small style additions for new buttons/fallbacks */
    .record-btn { font-size: 18px; padding: 10px 16px; border-radius: 10px; margin-top: 8px; }
    #voice-fallback { margin-top: 10px; color: #fff; font-size: 14px; }
    .status-indicator { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:8px; vertical-align:middle; }
    .status-active { background:#4CAF50; }
    .status-listening { background:#FF9800; }
    .status-inactive { background:#F44336; }
    /* ensure modal sizing works on mobile */
    .modal-content { max-width: 600px; margin: auto; padding: 18px; }
  </style>
</head>
<body>
  <header>
    <h1 class="main-title">Krishi Mitra</h1>
    <button id="openKisanGPT" class="kisan-button">üé§ Launch Kisan Voice Assistant</button>
  </header>

  <main>
    <div class="speech-control-buttons">
      <button id="startSpeakBtn" class="speak-button start-speak" disabled style="display: none;"></button>
      <button id="pauseSpeakBtn" class="speak-button pause-speak" style="display:none;">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="6" y="4" width="4" height="16"></rect>
          <rect x="14" y="4" width="4" height="16"></rect>
        </svg>
        ‡§∞‡•ã‡§ï‡•á‡§Ç (Pause)
      </button>
    </div>
  </main>

  <div id="kisanModal" class="modal" style="display:none;">
    <div class="modal-content">
      <span class="close-button" id="closeModal" style="float:right; font-size:24px; cursor:pointer;">&times;</span>
      <div class="logo">
        <svg width="80" height="80" viewBox="0 0 80 80">
          <circle cx="40" cy="40" r="38" fill="#e8f5e9" stroke="#4CAF50" stroke-width="2"/>
          <path d="M40,20 Q55,30 40,60 Q25,30 40,20" fill="#4CAF50"/>
          <circle cx="40" cy="25" r="5" fill="#81C784"/>
          <path d="M30,45 Q40,55 50,45" stroke="#2E7D32" stroke-width="2" fill="none"/>
        </svg>
      </div>

      <h1 class="app-title">‡§ï‡§ø‡§∏‡§æ‡§® GPT</h1>
      <p style="text-align: center; color: #333;">‡§Ü‡§™‡§ï‡§æ AI-‡§∏‡§Ç‡§ö‡§æ‡§≤‡§ø‡§§ ‡§ï‡•É‡§∑‡§ø ‡§∏‡§π‡§æ‡§Ø‡§ï</p>

      <div class="voice-controls">
        <h2 style="color: #333;">‡§∏‡•ç‡§µ‡§ö‡§æ‡§≤‡§ø‡§§ ‡§µ‡•â‡§á‡§∏ ‡§Æ‡•ã‡§°</h2>
        <p style="font-style: italic; color: #666;">‡§¨‡§∏ "‡§ï‡§ø‡§∏‡§æ‡§® ‡§ú‡•Ä‡§™‡•Ä‡§ü‡•Ä" ‡§Ø‡§æ "‡§ï‡§ø‡§∏‡§æ‡§®" ‡§Ø‡§æ "kisan" ‡§¨‡•ã‡§≤‡•á‡§Ç ‡§î‡§∞ ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§∏‡•Å‡§®‡•Ç‡§Ç‡§ó‡§æ</p>

        <div class="voice-status">
          <span class="status-indicator status-active" id="status-icon"></span>
          <span id="voice-status">‡§µ‡•á‡§ï ‡§µ‡§∞‡•ç‡§° ‡§ï‡§æ ‡§á‡§Ç‡§§‡§ú‡§º‡§æ‡§∞ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å</span>
        </div>

        <div class="toggle-container">
          <label class="toggle-switch">
            <input type="checkbox" id="voice-toggle" checked>
            <span class="slider"></span>
          </label>
          <span class="toggle-label">‡§µ‡•â‡§á‡§∏ ‡§Æ‡•ã‡§° ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à</span>
        </div>

        <div id="mobile-fallback-area"></div>

        <div class="control-buttons">
          <button id="pauseBtn" class="control-btn pause-btn">‚è∏Ô∏è Pause</button>
          <button id="resumeBtn" class="control-btn" disabled>‚ñ∂Ô∏è Resume</button>
        </div>
      </div>

      <div class="chat-container">
        <div class="chat-history" id="chat-history" style="max-height:220px; overflow:auto; border:1px solid #eee; padding:8px; border-radius:8px;"></div>
        <div class="response" id="response-area" style="min-height:60px; padding:8px; margin-top:8px;">‡§Ø‡§π‡§æ‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡§ø‡§ñ‡§æ‡§à ‡§¶‡•á‡§ó‡§æ...</div>
        <div class="chat-input" style="display:flex; gap:8px; margin-top:8px;">
          <select id="language-select" class="language-select">
            <option value="Hindi">‡§π‡§ø‡§Ç‡§¶‡•Ä</option>
            <option value="English">English</option>
            <option value="Garhwali">‡§ó‡§¢‡§º‡§µ‡§æ‡§≤‡•Ä</option>
            <option value="Punjabi">‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä</option>
            <option value="Tamil">‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç</option>
            <option value="Telugu">‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å</option>
            <option value="Marathi">‡§Æ‡§∞‡§æ‡§†‡•Ä</option>
          </select>
          <input type="text" id="query-input" placeholder="‡§´‡§∏‡§≤‡•ã‡§Ç, ‡§Æ‡•å‡§∏‡§Æ, ‡§ï‡•Ä‡§ü‡•ã‡§Ç ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§™‡•Ç‡§õ‡•á‡§Ç..." style="flex:1; padding:8px; border-radius:6px;">
          <button id="askBtn" class="control-btn">‡§™‡•Ç‡§õ‡•á‡§Ç</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  // ========== Minimal modifications for mobile/iPhone reliability ==========
  let userLocation = { latitude: null, longitude: null, locality: null, state: null, country: null, lastUpdated: null };

  function initLocationServices() {
    if (!navigator.geolocation) {
      console.error("Geolocation not supported");
      updateLocationStatus("Location services not available", "error");
      return;
    }
    getLocation();
    setInterval(getLocation, 30 * 60 * 1000);
  }
  function getLocation() {
    updateLocationStatus("Detecting your location...", "loading");
    const options = { enableHighAccuracy: true, timeout: 10000, maximumAge: 15 * 60 * 1000 };
    navigator.geolocation.getCurrentPosition(processPosition, handleLocationError, options);
  }
  function processPosition(position) {
    const { latitude, longitude } = position.coords;
    userLocation.latitude = latitude; userLocation.longitude = longitude; userLocation.lastUpdated = new Date();
    updateLocationStatus(`Coordinates: ${latitude.toFixed(4)}, ${longitude.toFixed(4)}`, "success");
    reverseGeocode(latitude, longitude);
    getLocalWeather(latitude, longitude);
  }
  function handleLocationError(error) {
    let message;
    switch(error.code) {
      case error.PERMISSION_DENIED: message = "User denied the request for location access"; break;
      case error.POSITION_UNAVAILABLE: message = "Location information is unavailable"; break;
      case error.TIMEOUT: message = "The request to get user location timed out"; break;
      default: message = "An unknown error occurred while retrieving location";
    }
    console.error("Location error:", message); updateLocationStatus(message, "error");
  }
  async function reverseGeocode(latitude, longitude) {
    try {
      const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=18&addressdetails=1`, { headers: { 'User-Agent': 'EcogenZ-AgricultureApp/1.0' }});
      if (!response.ok) throw new Error(`Geocoding failed with status: ${response.status}`);
      const data = await response.json();
      userLocation.locality = data.address.village || data.address.town || data.address.city || 'Unknown';
      userLocation.state = data.address.state || 'Unknown';
      userLocation.country = data.address.country || 'Unknown';
      updateLocationUI();
      if (data.address.country === "India") {
        if (languageSelect && languageSelect.value !== "Hindi") { languageSelect.value = "Hindi"; }
      }
      return data;
    } catch (error) {
      console.error("Reverse geocoding error:", error);
      updateLocationStatus("Couldn't resolve location name", "warning");
      return null;
    }
  }
  function updateLocationUI() {
    let locationDisplay = document.getElementById('location-display');
    if (!locationDisplay) {
      locationDisplay = document.createElement('div'); locationDisplay.id = 'location-display'; locationDisplay.className = 'location-info';
      const mainTitle = document.querySelector('.main-title');
      if (mainTitle && mainTitle.parentNode) { mainTitle.parentNode.insertBefore(locationDisplay, mainTitle.nextSibling); }
    }
    if (userLocation.locality && userLocation.state) {
      locationDisplay.innerHTML = `<div class="location-text"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg> ${userLocation.locality}, ${userLocation.state}</div>`;
    } else {
      locationDisplay.innerHTML = `<div class="location-text"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg> Location: Detecting...</div>`;
    }
  }
  function updateLocationStatus(message, status = "info") {
    console.log(`Location status: ${message} (${status})`);
    let statusElement = document.getElementById('location-status');
    if (!statusElement) {
      statusElement = document.createElement('div'); statusElement.id = 'location-status'; statusElement.style.cssText = 'font-size: 12px; margin-top: 5px; opacity: 0.8;';
      const locationDisplay = document.getElementById('location-display');
      if (locationDisplay) { locationDisplay.appendChild(statusElement); }
    }
    statusElement.textContent = message;
    switch(status) {
      case "success": statusElement.style.color = "#4CAF50"; break;
      case "error": statusElement.style.color = "#F44336"; break;
      case "warning": statusElement.style.color = "#FF9800"; break;
      case "loading": statusElement.style.color = "#2196F3"; break;
      default: statusElement.style.color = "#FFFFFF";
    }
  }

  async function getLocalWeather(latitude, longitude) {
    try {
      const API_KEY = "YOUR_OPENWEATHERMAP_API_KEY";
      const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&units=metric&appid=${API_KEY}`);
      if (!response.ok) throw new Error(`Weather API failed with status: ${response.status}`);
      const data = await response.json();
      const weatherInfo = { temperature: data.main.temp, humidity: data.main.humidity, windSpeed: data.wind.speed, description: data.weather[0].description, icon: data.weather[0].icon };
      window.currentWeather = weatherInfo;
      updateWeatherUI(weatherInfo);
      return weatherInfo;
    } catch (error) {
      console.error("Weather API error:", error);
      return null;
    }
  }

  function updateWeatherUI(weatherInfo) {
    if (!weatherInfo) return;
    let weatherDisplay = document.getElementById('weather-display');
    if (!weatherDisplay) {
      weatherDisplay = document.createElement('div'); weatherDisplay.id = 'weather-display'; weatherDisplay.className = 'weather-info';
      const header = document.querySelector('header'); if (header) header.appendChild(weatherDisplay);
    }
    weatherDisplay.innerHTML = `
      <div class="weather-card">
        <img src="https://openweathermap.org/img/wn/${weatherInfo.icon}@2x.png" alt="${weatherInfo.description}">
        <div class="weather-details">
          <div class="temperature">${weatherInfo.temperature.toFixed(1)}¬∞C</div>
          <div class="description">${weatherInfo.description}</div>
          <div class="extra-info">Humidity: ${weatherInfo.humidity}% | Wind: ${weatherInfo.windSpeed} m/s</div>
        </div>
      </div>
    `;
  }

  function getLocalCropRecommendations(latitude, longitude) {
    try {
      const regionalCrops = {
        "North India": ["Wheat", "Rice", "Maize", "Mustard"],
        "South India": ["Rice", "Coconut", "Spices", "Millets"],
        "East India": ["Rice", "Jute", "Tea", "Maize"],
        "West India": ["Cotton", "Groundnut", "Jowar", "Bajra"],
        "Central India": ["Soybean", "Wheat", "Pulses", "Cotton"],
        "Northeast India": ["Rice", "Tea", "Bamboo", "Fruits"]
      };
      let region = "North India";
      if (userLocation.state) {
        const stateToRegion = {
          "Punjab": "North India", "Haryana": "North India", "Uttar Pradesh": "North India", "Rajasthan": "North India",
          "Tamil Nadu": "South India", "Kerala": "South India", "Karnataka": "South India", "Andhra Pradesh": "South India", "Telangana": "South India",
          "West Bengal": "East India", "Odisha": "East India", "Bihar": "East India", "Jharkhand": "East India",
          "Gujarat": "West India", "Maharashtra": "West India", "Goa": "West India",
          "Madhya Pradesh": "Central India", "Chhattisgarh": "Central India",
          "Assam": "Northeast India", "Meghalaya": "Northeast India", "Tripura": "Northeast India", "Manipur": "Northeast India", "Nagaland": "Northeast India", "Mizoram": "Northeast India", "Arunachal Pradesh": "Northeast India", "Sikkim": "Northeast India"
        };
        region = stateToRegion[userLocation.state] || region;
      }
      const recommendedCrops = regionalCrops[region] || ["Rice", "Wheat", "Maize", "Pulses"];
      updateCropRecommendationsUI(recommendedCrops, region);
      return { region, recommendedCrops };
    } catch (error) {
      console.error("Error getting crop recommendations:", error); return null;
    }
  }

  function updateCropRecommendationsUI(crops, region) {
    let cropSection = document.getElementById('crop-recommendations');
    if (!cropSection) {
      cropSection = document.createElement('div'); cropSection.id = 'crop-recommendations'; cropSection.className = 'prediction-panel';
      const main = document.querySelector('main'); if (main) main.appendChild(cropSection);
    }
    cropSection.innerHTML = `
      <h2>üå± Recommended Crops for ${region}:</h2>
      <div class="crop-list">${crops.map(crop => `<div class="crop-item">${crop}</div>`).join('')}</div>
      <p class="crop-advice">Based on your location and the current season. For personalized recommendations, please upload soil test data.</p>
    `;
  }

  function addRequiredStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
      .location-info { display:flex; flex-direction:column; align-items:center; margin:5px 0 15px 0; font-size:18px; color:#FFF; }
      .location-text { display:flex; align-items:center; background-color: rgba(0,0,0,0.3); padding:5px; border-radius:15px; }
      .location-text svg { margin-right:5px; color:#FF5722; }
      .weather-info { margin-top:15px; width:90%; max-width:300px; }
      .weather-card { display:flex; align-items:center; background-color: rgba(0,0,0,0.3); border-radius:15px; padding:10px; }
      .weather-details { flex:1; }
      .temperature { font-size:24px; font-weight:bold; }
      .description { text-transform:capitalize; margin:5px 0; }
      .extra-info { font-size:12px; opacity:0.8; }
      .crop-list { display:flex; flex-wrap:wrap; gap:10px; margin:15px 0; }
      .crop-item { background-color: rgba(255,255,255,0.2); padding:5px 15px; border-radius:15px; font-weight:bold; }
      .crop-advice { font-size:14px; font-style:italic; opacity:0.9; }
    `;
    document.head.appendChild(styleElement);
  }

  function integrateLocationWithKisanGPT() {
    const originalGetKisanResponse = window.getKisanResponse;
    window.getKisanResponse = async function(userQuery, languagePreference) {
      let locationContext = "";
      if (userLocation.locality && userLocation.state) {
        locationContext = `The farmer is currently located in ${userLocation.locality}, ${userLocation.state}, ${userLocation.country}. `;
        const weatherKeywords = ["weather", "rain", "temperature", "climate", "mausam", "‡§Æ‡•å‡§∏‡§Æ", "‡§¨‡§æ‡§∞‡§ø‡§∂", "‡§§‡§æ‡§™‡§Æ‡§æ‡§®"];
        const hasWeatherQuery = weatherKeywords.some(keyword => userQuery.toLowerCase().includes(keyword.toLowerCase()));
        if (hasWeatherQuery && window.currentWeather) {
          locationContext += `Current weather conditions: ${window.currentWeather.temperature}¬∞C, ${window.currentWeather.description}, humidity ${window.currentWeather.humidity}%. `;
        }
      }
      const completePrompt = `${KISAN_SYSTEM_PROMPT}\n\n${locationContext}Farmer's Query: ${userQuery}\n\nProvide creative, engaging, CONCISE response in: ${languagePreference}`;
      try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${KISAN_GEMINI_API_KEY}`, {
          method: "POST", headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contents: [ { parts: [{ text: completePrompt }] } ] })
        });
        if (!response.ok) throw new Error(`Gemini API responded with status: ${response.status}`);
        const data = await response.json();
        const geminiResponse = data.candidates?.[0]?.content?.parts?.[0]?.text || "No response received.";
        return geminiResponse;
      } catch (error) {
        console.error("Error with Kisan Gemini API:", error);
        return "Error getting response: " + error.message;
      }
    };
  }

  // ========== Existing API keys & Supabase config (kept minimal changes) ==========
  const GEMINI_API_KEY = "AIzaSyAE8XprvLWF2Km9IGYUvl_5pDfo99syJgI";
  const SUPABASE_URL = "https://wrktsadpbrocmuyuztxl.supabase.co";
  const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Indya3RzYWRwYnJvY211eXV6dHhsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEzNjcwMzMsImV4cCI6MjA1Njk0MzAzM30.EDH66keNiSQB6wvsYJ-STKPQgIBRNj9QG7sAH0Xvm3s";
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
  const KISAN_GEMINI_API_KEY = "AIzaSyC4wUd5xMi_L_DklByDMq84oQ0q0NS4ERk";

  // Voice / recognition variables
  const WAKE_WORDS = ["‡§ï‡§ø‡§∏‡§æ‡§® ‡§ú‡•Ä‡§™‡•Ä‡§ü‡•Ä","‡§ï‡§ø‡§∏‡§æ‡§® gpt","‡§ï‡•Ä‡§∏‡§æ‡§®","‡§ï‡§ø‡§∏‡§æ‡§®","kisan gpt","kisan","kisaan"];
  let isWakeWordDetected = false; let isListening = false; let isProcessing = false; let isSpeaking = false; let continueListening = true; let isPaused = false;
  const predictionElement = document.createElement('div'); predictionElement.id = "prediction"; document.body.appendChild(predictionElement);
  const suggestionElement = document.createElement('div'); suggestionElement.id = "suggestion"; suggestionElement.style.marginTop = '8px'; document.body.appendChild(suggestionElement);

  // DOM elements
  const startSpeakBtn = document.getElementById("startSpeakBtn");
  const pauseSpeakBtn = document.getElementById("pauseSpeakBtn");
  const kisanModal = document.getElementById("kisanModal");
  const openKisanButton = document.getElementById("openKisanGPT");
  const closeModalButton = document.getElementById("closeModal");
  const queryInput = document.getElementById("query-input");
  const responseArea = document.getElementById("response-area");
  const chatHistory = document.getElementById("chat-history");
  const languageSelect = document.getElementById("language-select");
  const voiceStatus = document.getElementById("voice-status");
  const statusIcon = document.getElementById("status-icon");
  const voiceToggle = document.getElementById("voice-toggle");
  const toggleLabel = document.querySelector(".toggle-label");
  const pauseBtn = document.getElementById("pauseBtn");
  const resumeBtn = document.getElementById("resumeBtn");
  const askBtn = document.getElementById("askBtn");

  const synth = window.speechSynthesis;

  // ========== Fetch from Supabase (left mostly unchanged) ==========
  async function fetchFromSupabase() {
    try {
      if (SUPABASE_URL === "YOUR_SUPABASE_URL" || SUPABASE_KEY === "YOUR_SUPABASE_ANON_KEY") {
        console.warn("Supabase credentials not set. Using fallback data.");
        predictionElement.innerText = "Leaf Blight";
        getGeminiSuggestion("Leaf Blight");
        return;
      }
      const { data, error } = await supabase.from('disease_detections').select('prediction').order('timestamp', { ascending: false }).limit(1);
      if (error) { console.error("Error fetching from Supabase:", error); predictionElement.innerText = "Error: " + error.message; return; }
      if (data && data.length > 0) {
        const prediction = data[0].prediction || "Unknown";
        predictionElement.innerText = prediction;
        getGeminiSuggestion(prediction);
      } else { predictionElement.innerText = "No prediction data found."; }
    } catch (error) { console.error("Error:", error); predictionElement.innerText = "Error: " + error.message; }
  }

  async function getGeminiSuggestion(prediction) {
    const prompt = `‡§Æ‡•á‡§∞‡•á ‡§™‡•å‡§ß‡•á ‡§Æ‡•á‡§Ç ${prediction} ‡§¨‡•Ä‡§Æ‡§æ‡§∞‡•Ä ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡§π‡§≤‡•á ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§∏‡•Å‡§ù‡§æ‡§µ ‡§¶‡•á‡§Ç,fir wahi ‡§ó‡§¢‡§º‡§µ‡§æ‡§≤‡•Ä ‡§≠‡§æ‡§∑‡§æ ‡§Æ‡•á‡§Ç ‡§á‡§∏ ‡§¨‡•Ä‡§Æ‡§æ‡§∞‡•Ä ‡§ï‡§æ ‡§â‡§™‡§ö‡§æ‡§∞ ‡§î‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ ‡§¶‡•á‡§Ç ‡§î‡§∞ ‡§Ö‡§Ç‡§§ ‡§Æ‡•á‡§Ç ‡§Ö‡§Ç‡§ó‡•ç‡§∞‡•á‡§ú‡•Ä ‡§Æ‡•á‡§Ç ‡§≠‡•Ä ‡§≤‡§ø‡§ñ‡•á‡§Ç‡•§, give in short aur grape healthy bimaari nahi hai iss case mai to keep it healthy vo bataye`;
    try {
      suggestionElement.innerText = "Sending request to Gemini...";
      startSpeakBtn.disabled = true;
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`, {
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ contents: [ { parts: [{ text: prompt }] } ] })
      });
      if (!response.ok) throw new Error(`Gemini API responded with status: ${response.status}`);
      const data = await response.json();
      let suggestion = data.candidates?.[0]?.content?.parts?.[0]?.text || "No suggestion received.";
      suggestion = suggestion.replace(/\*/g, '');
      suggestionElement.innerText = suggestion;
      startSpeakBtn.disabled = false;
    } catch (error) {
      console.error("Error with Gemini API:", error);
      suggestionElement.innerText = "Error getting suggestions: " + error.message;
      startSpeakBtn.disabled = true;
    }
  }

  // ========== Speech synthesis helpers (safer for mobile) ==========
  let userInteracted = false;
  document.body.addEventListener('click', () => { userInteracted = true; }, { once: true });

  function safePlayBeep() {
    if (!userInteracted) return;
    try {
      const audio = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg');
      audio.play().catch(()=>{/* ignore autoplay error */});
    } catch (e) { /* ignore */ }
  }

  function speakDiseaseSuggestion() {
    const suggestion = suggestionElement.innerText;
    if (!suggestion || suggestion.includes("Error") || suggestion.includes("Sending request")) return;
    if (!synth) { alert("‡§Ü‡§™‡§ï‡§æ ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§µ‡•â‡§á‡§∏ ‡§∏‡§ø‡§Ç‡§•‡•á‡§∏‡§ø‡§∏ ‡§ï‡§æ ‡§∏‡§Æ‡§∞‡•ç‡§•‡§® ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡§æ ‡§π‡•à"); return; }
    startSpeakBtn.disabled = true; startSpeakBtn.style.display = "none"; pauseSpeakBtn.style.display = "inline-flex";
    if (synth.speaking) synth.cancel();
    const utterance = new SpeechSynthesisUtterance(suggestion);
    utterance.lang = 'hi-IN'; utterance.rate = 1.25;
    const voices = synth.getVoices();
    const hindiVoice = voices.find(voice => voice.lang.includes('hi-IN'));
    if (hindiVoice) utterance.voice = hindiVoice;
    utterance.onstart = () => { isSpeaking = true; };
    utterance.onend = () => { resetSpeakButtons(); };
    utterance.onerror = (event) => { console.log("Speech synthesis error:", event.error); resetSpeakButtons(); };
    synth.speak(utterance);
  }

  function pauseSpeaking() {
    if (synth.speaking) {
      if (synth.paused) {
        synth.resume();
        pauseSpeakBtn.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg> ‡§∞‡•ã‡§ï‡•á‡§Ç (Pause)`;
      } else {
        synth.pause();
        pauseSpeakBtn.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg> ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡•á‡§Ç (Resume)`;
      }
    } else {
      resetSpeakButtons();
    }
  }

  function resetSpeakButtons() {
    startSpeakBtn.disabled = false; startSpeakBtn.style.display = "inline-flex"; pauseSpeakBtn.style.display = "none"; isSpeaking = false;
  }
  startSpeakBtn.addEventListener('click', speakDiseaseSuggestion);
  pauseSpeakBtn.addEventListener('click', pauseSpeaking);
  window.addEventListener('beforeunload', function() { if (synth.speaking) synth.cancel(); });

  // ========== Kisan system prompt & getKisanResponse (kept same) ==========
  const KISAN_SYSTEM_PROMPT = `
    You are Kisan GPT, an engaging and creative agricultural assistant for Indian farmers.
    Your expertise includes:
    - Crop recommendations based on soil, climate, and region
    - Pest and disease management with natural and chemical options
    - Weather interpretation for agricultural decisions
    - Sustainable farming practices and innovative techniques
    - Market trends and pricing information with actionable insights
    - Government schemes and subsidies for farmers

    IMPORTANT GUIDELINES:
    1. Provide VERY CONCISE responses - limit to 1-3 short lines maximum
    2. Use storytelling and relatable examples when appropriate
    3. Include practical tips farmers can implement immediately
    4. Be conversational and warm, like talking to a trusted friend
    5. Balance tradition with new approaches
    6. Occasionally include a relevant rural proverb or saying
    7. Always prioritize sustainable farming methods when possible
    8. NEVER use asterisks in your responses
    9. Keep responses brief, practical and actionable
    10. Respond quickly with emphasis on speed

    MOST IMPORTANT: Provide responses a farmer can use today, with clear actions they can take.
  `;

  async function getKisanResponse(userQuery, languagePreference) {
    try {
      const completePrompt = `${KISAN_SYSTEM_PROMPT}\n\nFarmer's Query: ${userQuery}\n\nProvide creative, engaging, CONCISE response in: ${languagePreference}`;
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${KISAN_GEMINI_API_KEY}`, {
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ contents: [ { parts: [{ text: completePrompt }] } ] })
      });
      if (!response.ok) throw new Error(`Gemini API responded with status: ${response.status}`);
      const data = await response.json();
      const geminiResponse = data.candidates?.[0]?.content?.parts?.[0]?.text || "No response received.";
      return geminiResponse;
    } catch (error) {
      console.error("Error with Kisan Gemini API:", error);
      return "Error getting response: " + error.message;
    }
  }

  // ========== SpeechRecognition setup with mobile-safe fallbacks ==========
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || null;
  let wakeWordRecognition, commandRecognition;

  // detect iOS (approx) to disable continuous wake-word there
  const isIOS = /iP(hone|od|ad)/.test(navigator.userAgent);
  const isChromeOnAndroid = /Android/.test(navigator.userAgent) && /Chrome/.test(navigator.userAgent);

  function initializeVoiceRecognition() {
    // If recognition not supported, disable voice-based wake-word and show fallback
    if (!SpeechRecognition) {
      voiceStatus.textContent = "‡§á‡§∏ ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§Æ‡•á‡§Ç ‡§µ‡•â‡§á‡§∏ ‡§∏‡•Å‡§µ‡§ø‡§ß‡§æ ‡§∏‡•Ä‡§Æ‡§ø‡§§ ‡§π‡•à";
      voiceToggle.checked = false; voiceToggle.disabled = true;
      showMobileFallback(); // text/record fallback
      return;
    }

    // create recognizers
    wakeWordRecognition = new SpeechRecognition();
    wakeWordRecognition.continuous = true;
    wakeWordRecognition.interimResults = true;
    wakeWordRecognition.maxAlternatives = 5;
    wakeWordRecognition.lang = 'hi-IN';

    commandRecognition = new SpeechRecognition();
    commandRecognition.continuous = false;
    commandRecognition.interimResults = true;
    commandRecognition.lang = 'hi-IN';

    wakeWordRecognition.onstart = () => {
      console.log("Wake word detection started");
      statusIcon.className = "status-indicator status-active";
      voiceStatus.textContent = "‡§µ‡•á‡§ï ‡§µ‡§∞‡•ç‡§° ‡§ï‡§æ ‡§á‡§Ç‡§§‡§ú‡§º‡§æ‡§∞ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å";
    };

    wakeWordRecognition.onresult = (event) => {
      if (isPaused || isProcessing) return;
      const transcript = Array.from(event.results).map(result => result[0].transcript.toLowerCase().trim()).join(' ');
      console.log("Heard (wake detection):", transcript);
      const detected = WAKE_WORDS.some(word => transcript.includes(word.toLowerCase()));
      if (detected && !isWakeWordDetected) {
        console.log("Wake word detected!");
        isWakeWordDetected = true;
        try { wakeWordRecognition.stop(); } catch(e){/* ignore */ }
        statusIcon.className = "status-indicator status-listening"; voiceStatus.textContent = "‡§Ü‡§™‡§ï‡•ã ‡§∏‡•Å‡§® ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å...";
        safePlayBeep();
        setTimeout(() => { if (!isPaused) startCommandRecognition(); }, 500);
      }
    };

    wakeWordRecognition.onerror = (event) => {
      console.error("Wake word recognition error:", event.error);
      if (event.error === 'no-speech') {
        if (continueListening && !isPaused && !isWakeWordDetected) {
          try { wakeWordRecognition.stop(); } catch(e){}
          setTimeout(() => startWakeWordRecognition(), 300);
        }
      } else if (event.error === 'network') {
        voiceStatus.textContent = "‡§®‡•á‡§ü‡§µ‡§∞‡•ç‡§ï ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø - ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç";
        setTimeout(() => { if (continueListening && !isPaused) startWakeWordRecognition(); }, 3000);
      }
    };

    wakeWordRecognition.onend = () => {
      console.log("Wake word recognition ended");
      if (continueListening && !isPaused && !isWakeWordDetected) {
        setTimeout(() => startWakeWordRecognition(), 300);
      }
    };

    commandRecognition.onstart = () => { console.log("Command recognition started"); isListening = true; };
    commandRecognition.onresult = (event) => {
      const last = event.results.length - 1;
      const transcript = event.results[last][0].transcript.trim();
      console.log("Heard command:", transcript);
      queryInput.value = transcript;
      if (event.results[last].isFinal && transcript.length > 0) {
        commandRecognition.stop(); isListening = false; processUserQuery(transcript);
      }
    };
    commandRecognition.onerror = (event) => {
      console.error("Command recognition error:", event.error);
      isListening = false; resetVoiceState();
      if (event.error === 'no-speech') {
        voiceStatus.textContent = "‡§ï‡•ã‡§à ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§®‡§π‡•Ä‡§Ç ‡§∏‡•Å‡§®‡•Ä - ‡§µ‡•á‡§ï ‡§µ‡§∞‡•ç‡§° ‡§ï‡§æ ‡§á‡§Ç‡§§‡§ú‡§º‡§æ‡§∞ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å";
        startWakeWordRecognition();
      }
    };
    commandRecognition.onend = () => {
      console.log("Command recognition ended"); isListening = false;
      if (!isProcessing) resetVoiceState();
    };

    // If device is iOS (Safari) ‚Äî disable continuous wake-word by default and show push-to-talk
    if (isIOS) {
      console.log("iOS detected ‚Äî disabling continuous wake-word. Enabling push-to-talk fallback.");
      voiceToggle.checked = false; voiceToggle.disabled = true;
      showMobileFallback();
      voiceStatus.textContent = "iPhone detected ‚Äî ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§¨‡§ü‡§® ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç";
      statusIcon.className = "status-indicator status-inactive";
      return;
    }
  }

  function startWakeWordRecognition() {
    if (!SpeechRecognition || isPaused) return;
    // require a user gesture to start long-running continuous recognition on some phones
    if (!userInteracted && !isChromeOnAndroid) {
      console.log("Waiting for user gesture before starting wake-word (mobile autoplay restrictions).");
      return;
    }
    try { wakeWordRecognition.start(); statusIcon.className = "status-indicator status-active"; } catch (error) { console.error("Error starting wake word recognition:", error); setTimeout(() => startWakeWordRecognition(), 1000); }
  }

  function startCommandRecognition() {
    if (!SpeechRecognition || isPaused) return;
    try {
      commandRecognition.lang = getLanguageCode(languageSelect.value);
      commandRecognition.start();
    } catch (error) { console.error("Error starting command recognition:", error); resetVoiceState(); }
  }

  function resetVoiceState() {
    isWakeWordDetected = false; isProcessing = false;
    statusIcon.className = "status-indicator status-active"; voiceStatus.textContent = "‡§µ‡•á‡§ï ‡§µ‡§∞‡•ç‡§° ‡§ï‡§æ ‡§á‡§Ç‡§§‡§ú‡§º‡§æ‡§∞ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å";
    if (continueListening && !isPaused) startWakeWordRecognition();
  }

  function getLanguageCode(language) {
    const languageCodes = { 'Hindi': 'hi-IN', 'English': 'en-IN', 'Garhwali': 'hi-IN', 'Punjabi': 'pa-IN', 'Tamil': 'ta-IN', 'Telugu': 'te-IN', 'Marathi': 'mr-IN' };
    return languageCodes[language] || 'hi-IN';
  }

  async function processUserQuery(query) {
    if (!query || query.trim() === "") return;
    isProcessing = true;
    statusIcon.className = "status-indicator status-inactive"; voiceStatus.textContent = "‡§Ü‡§™‡§ï‡§æ ‡§â‡§§‡•ç‡§§‡§∞ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å...";
    addMessageToChat(query, 'farmer');
    responseArea.textContent = "‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§Æ‡§ø‡§≤ ‡§∞‡§π‡•Ä ‡§π‡•à...";
    const language = languageSelect.value;
    try {
      const response = await getKisanResponse(query, language);
      responseArea.textContent = response;
      addMessageToChat(response, 'assistant');
      if (voiceToggle.checked && !isPaused) {
        speakResponse(response, language);
      } else {
        resetVoiceState();
      }
    } catch (error) {
      console.error("Error processing query:", error);
      responseArea.textContent = "Error: " + error.message;
      resetVoiceState();
    }
  }

  function addMessageToChat(message, sender) {
    const messageElement = document.createElement('div');
    messageElement.className = `chat-message ${sender}`;
    messageElement.textContent = message;
    chatHistory.appendChild(messageElement);
    chatHistory.scrollTop = chatHistory.scrollHeight;
  }

  function speakResponse(text, language) {
    if (!synth) { console.log("Speech synthesis not available"); resetVoiceState(); return; }
    if (synth.speaking) synth.cancel();
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = getLanguageCode(language);
    utterance.rate = 1.2;
    const voices = synth.getVoices();
    const languageCode = getLanguageCode(language);
    const voice = voices.find(v => v.lang.includes(languageCode.split('-')[0]));
    if (voice) utterance.voice = voice;
    utterance.onstart = () => { isSpeaking = true; statusIcon.className = "status-indicator status-inactive"; voiceStatus.textContent = "‡§¨‡•ã‡§≤ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å..."; };
    utterance.onend = () => { isSpeaking = false; resetVoiceState(); };
    utterance.onerror = (event) => { console.error("Speech synthesis error:", event.error); isSpeaking = false; resetVoiceState(); };
    synth.speak(utterance);
  }

  function toggleVoiceMode() {
    continueListening = voiceToggle.checked;
    if (continueListening) {
      toggleLabel.textContent = "‡§µ‡•â‡§á‡§∏ ‡§Æ‡•ã‡§° ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à";
      if (!isPaused) startWakeWordRecognition();
    } else {
      toggleLabel.textContent = "‡§µ‡•â‡§á‡§∏ ‡§Æ‡•ã‡§° ‡§¨‡§Ç‡§¶ ‡§π‡•à";
      if (wakeWordRecognition) try { wakeWordRecognition.stop(); } catch(e){}
      if (commandRecognition) try { commandRecognition.stop(); } catch(e){}
      statusIcon.className = "status-indicator status-inactive"; voiceStatus.textContent = "‡§µ‡•â‡§á‡§∏ ‡§Æ‡•ã‡§° ‡§¨‡§Ç‡§¶ ‡§π‡•à";
    }
  }

  // ========== Mobile fallback UI: Push-to-talk (minimal, uses SpeechRecognition if available) ==========
  function showMobileFallback() {
    const area = document.getElementById('mobile-fallback-area');
    area.innerHTML = '';
    const info = document.createElement('div'); info.id = 'voice-fallback';
    info.innerHTML = `<p>‡§µ‡•â‡§á‡§∏ ‡§∞‡•á‡§ï‡§ó‡•ç‡§®‡§ø‡§∂‡§® ‡§á‡§∏ ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§™‡§∞ ‡§∏‡•Ä‡§Æ‡§ø‡§§ ‡§π‡•à‡•§ ‡§®‡•Ä‡§ö‡•á ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§¨‡§ü‡§® ‡§¶‡§¨‡§æ‡§ï‡§∞ ‡§¨‡•ã‡§≤‡•á‡§Ç (push-to-talk)‡•§</p>`;
    const btn = document.createElement('button'); btn.id = 'recordBtn'; btn.className = 'record-btn'; btn.textContent = 'üé§ ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§ï‡§∞‡•á‡§Ç';
    area.appendChild(info); area.appendChild(btn);

    let recording = false;
    btn.addEventListener('click', async () => {
      userInteracted = true; // mark gesture
      // If SpeechRecognition exists we can start a one-shot commandRecognition
      if (SpeechRecognition) {
        try {
          if (!commandRecognition) initializeVoiceRecognition(); // ensure created
          // set language based on select
          commandRecognition.lang = getLanguageCode(languageSelect.value);
          commandRecognition.start();
          voiceStatus.textContent = "‡§∏‡•Å‡§® ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å..."; statusIcon.className = "status-indicator status-listening";
          btn.textContent = 'Listening... Tap again to stop';
          // If user taps again, stop recognition
          const stopHandler = () => {
            try { commandRecognition.stop(); } catch(e){/* ignore */} btn.textContent = 'üé§ ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§ï‡§∞‡•á‡§Ç'; btn.removeEventListener('click', stopHandler);
          };
          btn.addEventListener('click', stopHandler, { once: true });
        } catch (e) {
          console.error("Error starting command recognition fallback:", e);
          alert("Voice recording not available. Please type your question.");
        }
      } else {
        // No SpeechRecognition - advise user to type
        alert("‡§µ‡•â‡§á‡§∏ ‡§∏‡•Å‡§µ‡§ø‡§ß‡§æ ‡§á‡§∏ ‡§°‡§ø‡§µ‡§æ‡§á‡§∏/‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ ‡§™‡§∞ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§á‡§®‡§™‡•Å‡§ü ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§");
      }
    });
  }

  // ========== UI events and init ==========
  openKisanButton.addEventListener('click', () => {
    kisanModal.style.display = "block";
    userInteracted = true; // user did gesture by opening modal
    if (voiceToggle.checked && !isPaused) startWakeWordRecognition();
  });
  closeModalButton.addEventListener('click', () => {
    kisanModal.style.display = "none";
    if (wakeWordRecognition) try { wakeWordRecognition.stop(); } catch(e){}
    if (commandRecognition) try { commandRecognition.stop(); } catch(e){}
    if (synth.speaking) synth.cancel();
  });

  askBtn.addEventListener('click', () => { processUserQuery(queryInput.value); });
  queryInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') processUserQuery(queryInput.value); });
  voiceToggle.addEventListener('change', toggleVoiceMode);
  pauseBtn.addEventListener('click', () => {
    isPaused = true; pauseBtn.disabled = true; resumeBtn.disabled = false;
    if (wakeWordRecognition) try { wakeWordRecognition.stop(); } catch(e){}
    if (commandRecognition) try { commandRecognition.stop(); } catch(e){}
    voiceStatus.textContent = "‡§µ‡•â‡§á‡§∏ ‡§∏‡•Å‡§µ‡§ø‡§ß‡§æ ‡§∞‡•ã‡§ï‡•Ä ‡§ó‡§à ‡§π‡•à"; statusIcon.className = "status-indicator status-inactive";
  });
  resumeBtn.addEventListener('click', () => {
    isPaused = false; pauseBtn.disabled = false; resumeBtn.disabled = true;
    if (voiceToggle.checked) startWakeWordRecognition();
  });

  // init on DOMContentLoaded (kept minimal)
  document.addEventListener('DOMContentLoaded', function() {
    addRequiredStyles();
    initLocationServices();
    updateLocationUI();
    integrateLocationWithKisanGPT();
    window.getLocalWeather = async function(lat, lon) { const weatherData = await getLocalWeather(lat, lon); window.currentWeather = weatherData; return weatherData; };
    console.log("Location services initialized");

    // Initialize recognition but respect mobile iOS fallback (initializeVoiceRecognition will show fallback if needed)
    initializeVoiceRecognition();

    // Setup mobile fallback UI if recognition missing or iOS
    if (!SpeechRecognition || isIOS) showMobileFallback();

    // populate voices after first user gesture (needed on iOS)
    document.body.addEventListener('click', () => {
      if (synth && speechSynthesis.onvoiceschanged !== undefined) {
        // trigger loading voices
        const v = synth.getVoices();
        console.log('voices loaded after gesture:', v);
      }
    }, { once: true });

    // Fetch from supabase (existing behavior)
    fetchFromSupabase();

    // close modal on outside click
    window.addEventListener('click', (event) => {
      if (event.target === kisanModal) {
        kisanModal.style.display = "none";
        if (wakeWordRecognition) try { wakeWordRecognition.stop(); } catch(e){}
        if (commandRecognition) try { commandRecognition.stop(); } catch(e){}
        if (synth.speaking) synth.cancel();
      }
    });
  });
  </script>
</body>
</html>
